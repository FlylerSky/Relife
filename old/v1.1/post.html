<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>One Social — Bài viết</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Open+Sans:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    @font-face {
  font-family: 'One OS UI 1';
  src: url('./SVN-Agency FB bold.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
}
    :root { --card-radius:14px; --shadow:0 6px 18px rgba(17,24,39,.06); --muted:#6c757d; }
    body { background:#f6f7fb; font-family: "One OS UI 1", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:#111827; }
    .container-main { max-width:920px; margin:20px auto; padding:0 12px; }
    .card-post { border-radius:var(--card-radius); padding:20px; box-shadow:var(--shadow); background:#fff; }
    .btn-rounded { border-radius:10px; }
    .user-avatar { width:48px; height:48px; border-radius:50%; object-fit:cover; }
    .badge-trial { background:#ffc107; color:#212529; padding:.2rem .45rem; border-radius:8px; font-size:.75rem; }
    .small-muted { color:var(--muted); }
    #__qs_hidden_renderer { position:absolute; left:-99999px; top:0; width:calc(100vw - 40px); max-width:1200px; opacity:0; pointer-events:none; }

    /* ===== responsive content fixes for post rendering ===== */
    .post-content { word-wrap:break-word; overflow-wrap:break-word; }
    .post-content img, .post-content video { max-width:100%; height:auto; display:block; margin:12px 0; object-fit:contain; }
    .post-content img.full-width { width:100%; }
    .post-content iframe { max-width:100%; width:100%; display:block; border:0; }
    /* Make embedded media (YouTube, etc.) maintain aspect ratio inside a responsive wrapper */
    .post-content .iframe-wrapper { position:relative; width:100%; max-width:100%; padding-bottom:56.25%; height:0; overflow:hidden; margin:12px 0; }
    .post-content .iframe-wrapper iframe, .post-content .iframe-wrapper video { position:absolute; top:0; left:0; width:100%; height:100%; }

    /* Tables: horizontal scroll on overflow */
    .post-content .table-wrapper { width:100%; overflow:auto; -webkit-overflow-scrolling:touch; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.02); margin:12px 0; }
    .post-content table { width:100%; border-collapse:collapse; }

    /* Lists: make sure bullet lists keep bullet style and wrap nicely */
    .post-content ul { list-style-type: disc; margin-left:1.25rem; padding-left:0; }
    .post-content ol { list-style-type: decimal; margin-left:1.25rem; padding-left:0; }
    .post-content ul li, .post-content ol li { word-break:break-word; overflow-wrap:break-word; }

    /* Code / pre blocks: enable wrapping and scroll for long lines */
    .post-content pre { white-space:pre-wrap; overflow:auto; padding:12px; border-radius:8px; background:#0f172a10; }
    .post-content code { word-break:break-word; }

    /* Prevent large elements from forcing horizontal scroll on small devices */
    img, video, iframe { max-width:100%; }

    /* Comments area: long comment text should wrap instead of overflowing */
    #commentsList { word-break:break-word; overflow-wrap:break-word; }
    #commentsList .comment-text { white-space:pre-wrap; word-break:break-word; overflow-wrap:break-word; }

    /* Minor adjustments for editor rendering area when used for capturing computed styles */
    #__qs_hidden_renderer { display:none; }
  </style>
</head>
<body>
  <div class="container container-main">
    <a href="index.html" class="btn btn-link mb-3"><i class="bi bi-arrow-left"></i> </a>

    <div id="postArea" class="card-post">
      <div id="loading" class="text-center py-5 text-muted">Đang tải...</div>
    </div>
  </div>

  <div id="__qs_hidden_renderer" aria-hidden="true" style="display:none"></div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.min.js"></script>

  <script type="module">
    import { initFirebase } from './firebase-config.js';
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import {
      doc, getDoc, updateDoc, increment,
      collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, writeBatch
    } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

    const db = initFirebase();
    const auth = getAuth();
    const params = new URLSearchParams(location.search);
    const postId = params.get('id');
    const postArea = document.getElementById('postArea');
    const hiddenRenderer = document.getElementById('__qs_hidden_renderer');

    const esc = s => String(s||'').replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#39;'}[m]));
    const fmtDate = ts => { try { return ts?.toDate ? ts.toDate().toLocaleString('vi-VN') : ''; } catch { return ''; } };

    const PURIFY_CFG_ALLOW_CLASS = {
      ADD_TAGS: ['iframe','table','thead','tbody','tfoot','tr','td','th','video','source','figure','figcaption','caption','pre','code','span'],
      ADD_ATTR: ['style','class','id','width','height','allow','allowfullscreen','frameborder','controls','playsinline','loading','referrerpolicy','sandbox','data-*'],
      FORBID_TAGS: ['script','object','embed'],
      KEEP_CONTENT: false
    };

    function inlineComputedStyles(root){
      if(!root) return;
      const walk = el => {
        if(el.nodeType !== 1) return;
        const cs = window.getComputedStyle(el);
        try {
          if(cs.fontSize) el.style.fontSize = cs.fontSize;
          if(cs.fontFamily) el.style.fontFamily = cs.fontFamily;
          if(cs.fontWeight) el.style.fontWeight = cs.fontWeight;
          if(cs.fontStyle && cs.fontStyle !== 'normal') el.style.fontStyle = cs.fontStyle;
          if(cs.textDecorationLine && cs.textDecorationLine !== 'none') el.style.textDecoration = cs.textDecorationLine;
          if(cs.color) el.style.color = cs.color;
          if(cs.backgroundColor && cs.backgroundColor !== 'rgba(0, 0, 0, 0)') el.style.backgroundColor = cs.backgroundColor;
          if(cs.textAlign && el.tagName.match(/^(P|DIV|H[1-6]|LI|BLOCKQUOTE)$/i)) el.style.textAlign = cs.textAlign;
          if(cs.lineHeight) el.style.lineHeight = cs.lineHeight;
          if(cs.letterSpacing && cs.letterSpacing !== 'normal') el.style.letterSpacing = cs.letterSpacing;
        } catch(e){}
        Array.from(el.children).forEach(child => walk(child));
      };
      walk(root);
    }

    async function renderDeltaPreserveStyles(delta){
      hiddenRenderer.style.display = 'block';
      hiddenRenderer.innerHTML = '';
      const temp = document.createElement('div');
      const editorHolder = document.createElement('div');
      editorHolder.className = 'ql-container ql-snow';
      temp.appendChild(editorHolder);
      hiddenRenderer.appendChild(temp);
      const q = new Quill(editorHolder, { theme: 'snow', readOnly: true, modules: { toolbar: false } });
      if(delta.ops) q.setContents(delta); else q.setContents({ ops: delta });
      const editor = editorHolder.querySelector('.ql-editor') || editorHolder.querySelector('[contenteditable]');
      inlineComputedStyles(editor);
      let html = editor.innerHTML;
      hiddenRenderer.innerHTML = '';
      hiddenRenderer.style.display = 'none';
      const sanitized = DOMPurify.sanitize(html, PURIFY_CFG_ALLOW_CLASS);
      return postProcessHtml(sanitized);
    }

    async function renderHtmlPreserveStyles(rawHtml){
      const sanitizedKeep = DOMPurify.sanitize(rawHtml, PURIFY_CFG_ALLOW_CLASS);
      hiddenRenderer.style.display = 'block';
      hiddenRenderer.innerHTML = `<div class="ql-editor">${sanitizedKeep}</div>`;
      const editor = hiddenRenderer.querySelector('.ql-editor');
      inlineComputedStyles(editor);
      let html = editor.innerHTML;
      hiddenRenderer.innerHTML = '';
      hiddenRenderer.style.display = 'none';
      const sanitizedFinal = DOMPurify.sanitize(html, PURIFY_CFG_ALLOW_CLASS);
      return postProcessHtml(sanitizedFinal);
    }

    function postProcessHtml(sanitizedHtml){
      const wrapper = document.createElement('div');
      wrapper.innerHTML = sanitizedHtml;
      wrapper.querySelectorAll('iframe').forEach(iframe => {
        if(iframe.closest('.iframe-wrapper')) return;
        const widthAttr = iframe.getAttribute('width') || iframe.style.width || '';
        const needsWrap = !widthAttr || widthAttr.includes('%') || widthAttr === '100%';
        if(needsWrap){
          const container = document.createElement('div');
          container.className = 'iframe-wrapper';
          iframe.parentNode.replaceChild(container, iframe);
          container.appendChild(iframe);
        } else {
          iframe.style.maxWidth = '100%';
        }
      });
      wrapper.querySelectorAll('table').forEach(tbl => {
        if(tbl.closest('.table-wrapper')) return;
        const w = document.createElement('div');
        w.className = 'table-wrapper';
        tbl.parentNode.replaceChild(w, tbl);
        w.appendChild(tbl);
      });
      wrapper.querySelectorAll('a').forEach(a => {
        if(!a.target) a.setAttribute('target','_blank');
        if(!a.rel) a.setAttribute('rel','noopener noreferrer');
      });
      return wrapper.innerHTML;
    }

    async function renderContent(rawContent){
      if(!rawContent && rawContent !== '') return '<div style="white-space:pre-wrap;color:#6c757d;">(Không có nội dung)</div>';
      if(typeof rawContent === 'object') return await renderDeltaPreserveStyles(rawContent);
      const str = String(rawContent).trim();
      if(str.startsWith('<')) return await renderHtmlPreserveStyles(rawContent);
      try {
        const parsed = JSON.parse(str);
        if((parsed && parsed.ops && Array.isArray(parsed.ops)) || (Array.isArray(parsed) && parsed.length)) return await renderDeltaPreserveStyles(parsed);
      } catch(e){}
      return `<div style="white-space:pre-wrap;">${esc(rawContent)}</div>`;
    }

    async function load(){
      if(!postId){ postArea.innerHTML = '<div class="p-4 text-center text-muted">ID bài viết không hợp lệ. <a href="index.html">Về trang chính</a></div>'; return; }
      const snap = await getDoc(doc(db,'posts',postId));
      if(!snap.exists()){ postArea.innerHTML = '<div class="p-4 text-center text-muted">Không tìm thấy bài viết</div>'; return; }
      const d = snap.data();

      let authorHtml = '';
      if(d.userId){
        const userSnap = await getDoc(doc(db,'users',d.userId));
        const prof = userSnap.exists() ? userSnap.data() : null;
        const avatar = prof?.avatarUrl ? prof.avatarUrl : `https://ui-avatars.com/api/?name=${encodeURIComponent(prof?.displayName||d.displayName||'U')}&background=0D6EFD&color=fff&size=128`;
        const tag = prof?.tagName || d.authorTag || '';
        authorHtml = `<div class="d-flex align-items-center gap-2 mb-2"><img src="${avatar}" class="user-avatar" alt="avatar"><div><div class="fw-bold">${esc(d.displayName || prof?.displayName || 'Người dùng')}</div><div class="small-muted">${esc(tag)}</div></div></div>`;
      } else {
        authorHtml = `<div class="mb-2"><div class="fw-bold">${esc(d.displayName || 'Tài khoản thử nghiệm')}</div><div><span class="badge-trial">Tài khoản thử nghiệm</span></div></div>`;
      }

      const raw = d.content || '';
      let rendered = '';
      try {
        rendered = await renderContent(raw);
      } catch(err){
        console.error('Render failed', err);
        rendered = DOMPurify.sanitize(String(raw), PURIFY_CFG_ALLOW_CLASS);
      }

      const hashtagsHtml = (d.hashtags||[]).map(h=>`<a href="tag.html?tag=${encodeURIComponent(h)}" class="small-muted me-2">${esc(h)}</a>`).join(' ');

      postArea.innerHTML = `
        <div>${authorHtml}</div>
        <h4>${esc(d.title || '')}</h4>
        <div class="small-muted mb-2">${fmtDate(d.createdAt)}</div>
        <hr>
        <div id="postContentContainer" class="post-content mb-3">${rendered}</div>
        <div class="mb-3">${hashtagsHtml}</div>

        <div class="d-flex gap-2 align-items-center mb-3">
          <button id="likeBtn" class="btn btn-outline-primary btn-sm btn-rounded"><i class="bi bi-hand-thumbs-up"></i> <span id="likeCount">${d.likes||0}</span></button>
          <button id="dislikeBtn" class="btn btn-outline-danger btn-sm btn-rounded"><i class="bi bi-hand-thumbs-down"></i> <span id="dislikeCount">${d.dislikes||0}</span></button>
          <button id="commentToggle" class="btn btn-outline-secondary btn-sm btn-rounded ms-2"><i class="bi bi-chat"></i> <span id="commentCount">${d.commentsCount||0}</span></button>
          <button id="shareBtn" class="btn btn-outline-success btn-sm btn-rounded ms-auto"><i class="bi bi-share"></i> Chia sẻ</button>
        </div>

        <hr>
        <h6>Bình luận</h6>
        <div id="commentsList" class="mb-3"></div>
        <div id="loginNotice" class="alert alert-warning" style="display:none;">Bạn cần đăng nhập để viết bình luận.</div>
        <div id="commentFormArea" style="display:none;">
          <textarea id="commentText" class="form-control mb-2" rows="3" placeholder="Viết bình luận..."></textarea>
          <button id="sendComment" class="btn btn-primary btn-rounded w-100">Gửi</button>
        </div>
      `;

      bindEvents();
      watchRealtime();
      updateReactionButtonsState();
    }

    let commentsUnsub = null;
    function watchRealtime(){
      const commentsRef = collection(db,'posts',postId,'comments');
      const q = query(commentsRef, orderBy('createdAt','desc'));
      if(commentsUnsub) commentsUnsub();
      commentsUnsub = onSnapshot(q, snap => {
        const list = document.getElementById('commentsList'); list.innerHTML = '';
        if(snap.empty){ list.innerHTML = '<div class="text-muted">Chưa có bình luận</div>'; return; }
        snap.forEach(s => {
          const c = s.data();
          list.innerHTML += `<div class="mb-3"><div class="fw-bold">${esc(c.displayName||'')}</div><div class="small-muted">${fmtDate(c.createdAt)}</div><div class="comment-text">${esc(c.text)}</div><hr></div>`;
        });
      });

      const postRef = doc(db,'posts',postId);
      onSnapshot(postRef, snap => {
        const d = snap.data();
        if(!d) return;
        const likeEl = document.getElementById('likeCount');
        const disEl = document.getElementById('dislikeCount');
        const comEl = document.getElementById('commentCount');
        if(likeEl) likeEl.textContent = d.likes || 0;
        if(disEl) disEl.textContent = d.dislikes || 0;
        if(comEl) comEl.textContent = d.commentsCount || 0;
      });
    }

    function bindEvents(){
      document.getElementById('shareBtn').addEventListener('click', async ()=>{
        try { await navigator.clipboard.writeText(location.href); const btn = document.getElementById('shareBtn'); const old = btn.innerHTML; btn.innerHTML = '<i class="bi bi-check-lg"></i> Đã sao chép'; setTimeout(()=> btn.innerHTML = old, 1200); } catch(e){ alert('Không thể sao chép URL'); }
      });

      document.getElementById('likeBtn').addEventListener('click', ()=> toggleReaction(postId, 'like'));
      document.getElementById('dislikeBtn').addEventListener('click', ()=> toggleReaction(postId, 'dislike'));
      document.getElementById('commentToggle').addEventListener('click', ()=> { const area = document.getElementById('commentFormArea'); area.scrollIntoView({ behavior:'smooth', block:'center' }); });

      document.getElementById('sendComment').addEventListener('click', async ()=>{
        const text = document.getElementById('commentText').value.trim();
        if(!text) return alert('Viết bình luận trước khi gửi.');
        const user = auth.currentUser;
        if(!user) return alert('Bạn cần đăng nhập để bình luận.');
        const udoc = await getDoc(doc(db,'users',user.uid)); const prof = udoc.exists() ? udoc.data() : null;
        await addDoc(collection(db,'posts',postId,'comments'), { displayName: prof?.displayName || user.email, userId: user.uid, text, createdAt: serverTimestamp() });
        await updateDoc(doc(db,'posts',postId), { commentsCount: increment(1) });
        document.getElementById('commentText').value = '';
      });

      onAuthStateChanged(auth, user => {
        if(user){ document.getElementById('loginNotice').style.display = 'none'; document.getElementById('commentFormArea').style.display = 'block'; }
        else { document.getElementById('loginNotice').style.display = 'block'; document.getElementById('commentFormArea').style.display = 'none'; }
        updateReactionButtonsState();
      });
    }

    async function updateReactionButtonsState(){
      const user = auth.currentUser;
      const likeBtn = document.getElementById('likeBtn');
      const disBtn = document.getElementById('dislikeBtn');
      if(!likeBtn || !disBtn) return;
      likeBtn.classList.remove('btn-primary'); likeBtn.classList.add('btn-outline-primary');
      disBtn.classList.remove('btn-danger'); disBtn.classList.add('btn-outline-danger');
      if(!user) return;
      try {
        const likeDoc = await getDoc(doc(db,'posts',postId,'likes',user.uid));
        if(likeDoc.exists()){
          const t = likeDoc.data().type;
          if(t === 'like'){ likeBtn.classList.remove('btn-outline-primary'); likeBtn.classList.add('btn-primary'); }
          else if(t === 'dislike'){ disBtn.classList.remove('btn-outline-danger'); disBtn.classList.add('btn-danger'); }
        }
      } catch(e){ console.error(e); }
    }

    async function toggleReaction(postId, reaction){
      const user = auth.currentUser;
      if(!user){ alert('Bạn cần đăng nhập để tương tác (Like/Dislike).'); return; }
      const likeDocRef = doc(db,'posts',postId,'likes',user.uid);
      const postRef = doc(db,'posts',postId);
      const likeSnap = await getDoc(likeDocRef);
      const batch = writeBatch(db);
      if(!likeSnap.exists()){
        batch.set(likeDocRef, { userId: user.uid, type: reaction, createdAt: serverTimestamp() });
        if(reaction === 'like') batch.update(postRef, { likes: increment(1) }); else batch.update(postRef, { dislikes: increment(1) });
      } else {
        const prev = likeSnap.data().type;
        if(prev === reaction){
          batch.delete(likeDocRef);
          if(reaction === 'like') batch.update(postRef, { likes: increment(-1) }); else batch.update(postRef, { dislikes: increment(-1) });
        } else {
          batch.update(likeDocRef, { type: reaction, updatedAt: serverTimestamp() });
          if(reaction === 'like') batch.update(postRef, { likes: increment(1), dislikes: increment(-1) }); else batch.update(postRef, { dislikes: increment(1), likes: increment(-1) });
        }
      }
      try { await batch.commit(); updateReactionButtonsState(); } catch(err){ console.error('Reaction failed', err); alert('Không thể cập nhật phản hồi — thử lại sau.'); }
    }

    load();
  </script>
</body>
</html>
